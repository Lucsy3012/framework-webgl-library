<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        body { margin: 0; min-height: 8000px; overflow-x: hidden; }
        canvas { display: block; background: linear-gradient(39deg, rgba(15,28,84,1) 0%, rgba(3,1,15,1) 100%); }
        #canvas-container { position: sticky; top: 0; }
        #canvas-container.no-orbiting canvas { pointer-events: none; }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<script src="js/three.js"></script>
<script type="module">

    // import * as THREE from './js/three.js';
    import { OrbitControls } from './js/OrbitControls.js';

    var container;
    var camera, scene, renderer, controls;
    var framesCount = 0;

    // Project Variables
    var points = [],
        separation = 5,
        length = 10;

    var material, geometry;

    // Camera Variables
    var cameraPosition = new THREE.Vector3(0, 0, -10),
        cameraRotationX = 0,
        cameraRotationY = 0,
        cameraRotationZ = 0;

    init();
    sceneAnimation();

    // Initiating Scene
    function init() {

        // INIT Scene
        // --------------------------------------

        scene = new THREE.Scene();


        // INIT Camera
        // --------------------------------------

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
        camera.rotation.set(0, Math.PI, 0);

        // INIT Renderer
        // --------------------------------------

        renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearAlpha(0);

        container = document.getElementById('canvas-container');
        container.appendChild(renderer.domElement);

        // INIT Options
        // --------------------------------------

        // Grid
        // helperGrid();

        // Lights
        addLights();

        // Controls
        // addControls();

        // Create box
        addLines();

        // Create fog
        scene.fog = new THREE.FogExp2(0x090e31, 0.0265);

        // Update renderer and camera when resizing
        window.addEventListener('resize', onWindowResize, false);

        window.addEventListener('scroll', function() { cameraPaningZ(0.02, -0.0005); }, true);
    }


    // Rendering the scene
    function sceneAnimation() {
        requestAnimationFrame(sceneAnimation);

        framesCount++;

        // camera.position.z = framesCount * 0.05;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function cameraPaningX(positionRate = 0.02, rotationRate = -0.0002, scrollDirectionY = true, disableOrbiting = true) {
        let scrollPosition = window.pageYOffset;

        if (scrollDirectionY !== true) {
            scrollPosition = window.pageXOffset;
        }

        if (disableOrbiting === true) {
            container.classList.add('no-orbiting');
        }

        if (positionRate) {
            camera.position.x = cameraPosition.x + (scrollPosition * positionRate);
        }

        if (rotationRate) {
            camera.rotation.y = cameraRotationY + scrollPosition * rotationRate;
        }

    }

    function cameraPaningY(positionRate = 0.02, rotationRate = -0.0002, scrollDirectionY = true, disableOrbiting = true) {
        let scrollPosition = window.pageYOffset;

        if (scrollDirectionY !== true) {
            scrollPosition = window.pageXOffset;
        }

        if (disableOrbiting === true) {
            container.classList.add('no-orbiting');
        }

        if (positionRate) {
            camera.position.y = cameraPosition.y + (scrollPosition * positionRate);
        }

        if (rotationRate) {
            camera.rotation.x = cameraRotationX + scrollPosition * rotationRate;
        }

    }

    function cameraPaningZ(positionRate = 0.02, rotationRate = -0.0002, scrollDirectionY = true, disableOrbiting = true) {
        let scrollPosition = window.pageYOffset;

        if (scrollDirectionY !== true) {
            scrollPosition = window.pageXOffset;
        }

        if (disableOrbiting === true) {
            container.classList.add('no-orbiting');
        }

        if (positionRate) {
            camera.position.z = cameraPosition.z + (scrollPosition * positionRate);
        }

        if (rotationRate) {
            camera.rotation.z = cameraRotationZ + scrollPosition * rotationRate;
        }
    }

    function helperGrid() {
        var grid = new THREE.GridHelper(0, 0);
        scene.add(grid);
    }

    function addLights() {
        var ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        var pointLight = new THREE.PointLight(0xffffff, 1, 500);
        pointLight.position.set(0, 0, 50);

        scene.add(pointLight);
    }

    function addControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.minDistance = 2;
        controls.maxDistance = 60;
        controls.target.set(0, 0, 0);
        controls.update();
    }

    function addLines() {

        var material = new THREE.LineBasicMaterial( { color: 0x00ff00 } );

        let i = 0;

        for (i = 0; i < 100; ++i) {

            points = [];
            points.push(new THREE.Vector3(-length, 0, i * separation));
            points.push(new THREE.Vector3(0, length, i * separation));
            points.push(new THREE.Vector3(length, 0, i * separation));
            points.push(new THREE.Vector3(0, -length, i * separation));
            points.push(new THREE.Vector3(-length, 0, i * separation));

            var geometry   = new THREE.BufferGeometry().setFromPoints(points);
            var line       = new THREE.Line(geometry, material);

            scene.add(line);

        }

    }

</script>

</body>
</html>